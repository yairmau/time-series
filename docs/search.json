[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Time Series Analysis",
    "section": "",
    "text": "About"
  },
  {
    "objectID": "index.html#disclaimer",
    "href": "index.html#disclaimer",
    "title": "Time Series Analysis",
    "section": "Disclaimer",
    "text": "Disclaimer\n\nThe material here is not comprehensive and does not constitute a stand alone course in Time Series Analysis. This is only the support material for the actual presential course I give."
  },
  {
    "objectID": "index.html#when-and-where",
    "href": "index.html#when-and-where",
    "title": "Time Series Analysis",
    "section": "When and Where?",
    "text": "When and Where?\n Day of the week, from 00:00 to 24:00\n Computer classroom #16"
  },
  {
    "objectID": "index.html#syllabus",
    "href": "index.html#syllabus",
    "title": "Time Series Analysis",
    "section": "Syllabus",
    "text": "Syllabus\n\nCourse description\nData analysis of time series, with practical examples from environmental sciences.\n\n\nCourse aims\nThis course aims at giving the students a broad overview of the main steps involved in the analysis of time series: data management, data wrangling, visualization, analysis, and forecast. The course will provide a hands-on approach, where students will actively engage with real-life datasets from the field of environmental science.\n\n\nLearning outcomes\nOn successful completion of this module,students should be able to:\n\nExplore a time-series dataset, while formulating interesting questions.\nChoose the appropriate tools to attack the problem and answer the questions.\nCommunicate their findings and the methods they used to achieve them, using graphs, statistics, text, and a well-documented code.\n\n\n\nCourse content\n\nData wrangling: organization, cleaning, merging, filling gaps, excluding outliers, smoothing, resampling.\nVisualization: best practices for graph making using leading python libraries.\nAnalysis: stationarity, seasonality, (auto)correlations, lags, derivatives, spectral analysis.\nForecast: ARIMA\nData management: how to plan ahead and best organize large quantities of data. If there is enough time, we will build a simple time-series database.\n\n\n\nBooks and other sources\n\n\nCourse evaluation\nThere will be 2 projects during the semester (each worth 25% of the final grade), and one final project (50%)."
  },
  {
    "objectID": "index.html#weekly-program",
    "href": "index.html#weekly-program",
    "title": "Time Series Analysis",
    "section": "Weekly program",
    "text": "Weekly program\n\nWeek 1\n\nLecture: Course overview, setting of expectations. Introduction, basic concepts, continuous vs discrete time series, sampling, aliasing\nExercise: Loading csv file into python, basic time series manipulation with pandas and plotting\n\n\n\nWeek 2\n\nLecture: Filling gaps, removing outliers\nExercise: Practice the same topics learned during the lecture. Data: air temperature and relative humidity\n\n\n\nWeek 3\n\nLecture: Interpolation, resampling, binning statistics\nExercise: Practice the same topics learned during the lecture. Data: air temperature and relative humidity, precipitation\n\n\n\nWeek 4\n\nLecture: Time series plotting: best practices. Dos and don’ts and maybes\nExercise: Practice with Seaborn, Plotly, Pandas, Matplotlib\n\n\nProject 1\nBasic data wrangling, using real data (temperature, relative humidity, precipitation) downloaded from USGS. 25% of the final grade\n\n\n\nWeek 5\n\nLecture: Smoothing, running averages, convolution\nExercise: Practice the same topics learned during the lecture. Data: sap flow, evapotranspiration\n\n\n\nWeek 6\n\nLecture: Strong and weak stationarity, stochastic processes, auto-correlation\nExercise: Practice the same topics learned during the lecture. Data: temperature and wind speed\n\n\n\nWeek 7\n\nLecture: Correlation between signals. Pearson correlation, time-lagged cross-correlations, dynamic time warping\nExercise: Practice the same topics learned during the lecture. Data: temperature, solar radiation, relative humidity, soil moisture, evapotranspiration\n\n\n\nWeek 8\nSame as lecture 7 above\n\n\nWeek 9\n\nLecture: Download data from repositories, using API, merging, documentation\nExercise: Download data from USGS, NOAA, Fluxnet, Israel Meteorological Service\n\n\nProject 2\nStudents will study a Fluxnet site of their choosing. How do gas fluxes (CO2, H2O) depend on environmental conditions? 25% of the final grade\n\n\n\nWeek 10\n\nLecture: Fourier decomposition, filtering, Nyquist–Shannon sampling theorem\nExercise: Practice the same topics learned during the lecture. Data: dendrometer data\n\n\n\nWeek 11\n\nLecture: Seasonality, seasonal decomposition (trend, seasonal, residue), Hilbert transform\nExercise: Practice the same topics learned during the lecture. Data: monthly atmospheric CO2 concentration, hourly air temperature\n\n\n\nWeek 12\n\nLecture: Derivatives, differencing\nExercise: Practice the same topics learned during the lecture. Data: dendrometer data\n\n\n\nWeek 13\n\nLecture: Forecasting. ARIMA\nExercise: Practice the same topics learned during the lecture. Data: vegetation variables (sap flow, ET, DBH, etc)\n\n\nFinal Project\nIn consultation with the lecturer, students will ask a specific scientific question about a site of their choosing (from NOAA, USGS, Fluxnet), and answer it using the tools learned during the semester. The report will be written in Jupyter Notebook, combining in one document all the calculations, documentation, figures, analysis, and discussion. 50% of the final grade."
  },
  {
    "objectID": "outliers/outliers.html",
    "href": "outliers/outliers.html",
    "title": "Outliers and Gaps",
    "section": "",
    "text": "Z-score\n\\[\nz  = \\frac{x-\\mu}{\\sigma},\n\\]\nwhere \\(x\\) is a data point, \\(\\mu\\) is the time series mean, and \\(\\sigma\\) is the time series standard deviation.\ndef zscore(df, degree=3):\n    data = df.copy()\n    data['zscore'] = (data - data.mean())/data.std()\n    outliers = data[(data['zscore'] &lt;= -degree) | (data['zscore'] &gt;= degree)]\n    return outliers['value'], data\nNow we can simply use this function:\nthreshold = 2.5\noutliers, transformed = zscore(tx, threshold)\nSource: Atwan (2022)\n\n\n\n\nAtwan, Tarek A. 2022. Time Series Analysis with Python Cookbook: Practical Recipes for Exploratory Data Analysis, Data Preparation, Forecasting, and Model Evaluation. Packt."
  },
  {
    "objectID": "outliers/zscore.html",
    "href": "outliers/zscore.html",
    "title": "1  Z-score",
    "section": "",
    "text": "\\[\nz  = \\frac{x-\\mu}{\\sigma},\n\\]\nwhere\n\n\\(x\\) is a data point,\n\\(\\mu\\) is the time series mean, and\n\\(\\sigma\\) is the time series standard deviation.\n\ndef zscore(df, degree=3):\n    data = df.copy()\n    data['zscore'] = (data - data.mean())/data.std()\n    outliers = data[(data['zscore'] &lt;= -degree) | (data['zscore'] &gt;= degree)]\n    return outliers['value'], data\nNow we can simply use this function:\nthreshold = 2.5\noutliers, transformed = zscore(tx, threshold)\nSource: Atwan (2022)\n\n\n\n\nAtwan, Tarek A. 2022. Time Series Analysis with Python Cookbook: Practical Recipes for Exploratory Data Analysis, Data Preparation, Forecasting, and Model Evaluation. Packt."
  },
  {
    "objectID": "introduction/first-steps.html#nan-missing-data-outliers",
    "href": "introduction/first-steps.html#nan-missing-data-outliers",
    "title": "2  First Steps — basic time series analysis",
    "section": "2.1 NaN, Missing data, Outliers",
    "text": "2.1 NaN, Missing data, Outliers\n\n# %matplotlib widget\n\nstart = \"2022-05-03 12:00:00\"\nend = \"2022-05-06 00:00:00\"\n\nfig, ax = plt.subplots(1, figsize=(8,4))\n\n# plot using pandas' plot method\ndf.loc[start:end, 'T2'].plot(ax=ax,\n                             linestyle='-',\n                             marker='o',\n                             color=\"tab:blue\",\n                             label=\"data\")\n\n# annotate examples here:\n# https://jakevdp.github.io/PythonDataScienceHandbook/04.09-text-and-annotation.html\nax.annotate(\"NaN\",                             # text to write, if nothing, then \"\"\n            xy=('2022-05-03 20:30:00', 25),    # (x,y coordinates for the tip of the arrow)\n            xycoords='data',                   # xy as 'data' coordinates\n            xytext=(-20, 60),                  # xy coordinates for the text\n            textcoords='offset points',        # xytext relative to xy\n            arrowprops=dict(arrowstyle=\"-&gt;\")   # pretty arrow\n           )\nax.annotate(\"outlier\",\n            xy=('2022-05-03 22:30:00', 85),\n            xycoords='data',\n            xytext=(40, -20),\n            textcoords='offset points',\n            arrowprops=dict(arrowstyle=\"-&gt;\")\n           )\nax.annotate(\"missing rows\",\n            xy=('2022-05-05 00:00:00', 25),\n            xycoords='data',\n            xytext=(0, 40),\n            textcoords='offset points',\n            arrowprops=dict(arrowstyle=\"-&gt;\")\n           )\n\nax.xaxis.set_major_formatter(mdates.DateFormatter('%d %b, %H:00'))\nplt.gcf().autofmt_xdate()\nax.set(xlabel=\"\",\n       ylabel=\"Temperature (deg C)\")\n\n[Text(0.5, 0, ''), Text(0, 0.5, 'Temperature (deg C)')]\n\n\n\n\n\nThe arrows (annotate) work because the plot was\ndf['column'].plot()\nIf you use the usual\nax.plot(df['column'])\nthen you matplotlib will not understand timestamps as x-positions. In this case follow the instructions below.\n\n# %matplotlib widget\n\nstart = \"2022-05-03 12:00:00\"\nend = \"2022-05-06 00:00:00\"\n\nfig, ax = plt.subplots(1, figsize=(8,4))\n\nax.plot(df.loc[start:end, 'T2'], linestyle='-', marker='o', color=\"tab:blue\", label=\"data\")\n\nt_nan = '2022-05-03 20:30:00'\nx_nan = mdates.date2num(dt.datetime.strptime(t_nan, \"%Y-%m-%d %H:%M:%S\"))\nax.annotate(\"NaN\",\n            xy=(x_nan, 25),\n            xycoords='data',\n            xytext=(-20, 60),\n            textcoords='offset points',\n            arrowprops=dict(arrowstyle=\"-&gt;\")\n           )\nt_outlier = '2022-05-03 22:30:00'\nx_outlier = mdates.date2num(dt.datetime.strptime(t_outlier, \"%Y-%m-%d %H:%M:%S\"))\nax.annotate(\"outlier\",\n            xy=(x_outlier, 85),\n            xycoords='data',\n            xytext=(40, -20),\n            textcoords='offset points',\n            arrowprops=dict(arrowstyle=\"-&gt;\")\n           )\nt_missing = '2022-05-05 00:00:00'\nx_missing = mdates.date2num(dt.datetime.strptime(t_missing, \"%Y-%m-%d %H:%M:%S\"))\nax.annotate(\"missing rows\",\n            xy=(x_missing, 25),\n            xycoords='data',\n            xytext=(0, 40),\n            textcoords='offset points',\n            arrowprops=dict(arrowstyle=\"-&gt;\")\n           )\n# code for hours, days, etc\n# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\nax.xaxis.set_major_formatter(mdates.DateFormatter('%d %b, %H:00'))\nplt.gcf().autofmt_xdate()\nax.set(xlabel=\"\",\n       ylabel=\"Temperature (deg C)\")\n\n[Text(0.5, 0, ''), Text(0, 0.5, 'Temperature (deg C)')]\n\n\n\n\n\n\n# %matplotlib widget\n\nfig, ax = plt.subplots(1, figsize=(8,4))\n\ndelta_index = (df.index.to_series().diff() / pd.Timedelta('1 sec') ).values\nax.plot(delta_index)\nax.set(ylim=[0, 100],\n       xlabel=\"running index\",\n       ylabel=r\"$\\Delta t$ (s)\",\n       title=\"Time difference between consecutive rows\")\n\n[(0.0, 100.0),\n Text(0.5, 0, 'running index'),\n Text(0, 0.5, '$\\\\Delta t$ (s)'),\n Text(0.5, 1.0, 'Time difference between consecutive rows')]"
  },
  {
    "objectID": "introduction/first-steps.html#resample",
    "href": "introduction/first-steps.html#resample",
    "title": "2  First Steps — basic time series analysis",
    "section": "2.2 Resample",
    "text": "2.2 Resample\n\n2.2.1 Downsampling\n\n# %matplotlib widget\n\nfig, ax = plt.subplots(1, figsize=(8,4))\n\n# Downsample to spaced out data points. Change the number below, see what happens.\nwindow_size = '15min'\ndf_resampled = (df['T2'].resample(window_size)  # resample doesn't do anything yet, just divides data into buckets\n                        .mean()                 # this is where stuff happens. you can also choose \"sum\", \"max\", etc\n               )\n# optional, add half a window size to timestamp\ndf_resampled.index = df_resampled.index + to_offset(window_size) / 2\n\nax.plot(df['T2'], color=\"tab:blue\", label=\"original data\")\nax.plot(df_resampled, marker='x', color=\"tab:orange\", zorder=-1,\n        label=f\"resampled {window_size} data\")\nax.legend()\n\nax.set(xlabel=\"time\",\n       ylabel=\"temperature (deg C)\")\n\n[Text(0.5, 0, 'time'), Text(0, 0.5, 'temperature (deg C)')]\n\n\n\n\n\n\n\n2.2.2 Filling missing data\n\n# %matplotlib widget\n\nfig, ax = plt.subplots(1, figsize=(8,4))\n\n# see options for interpolation methods here:\n# https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.interpolate.html\ndf_interpolated1 = df_resampled.interpolate(method='time')\ndf_interpolated2 = df_resampled.interpolate(method='nearest')\n\nax.plot(df_resampled, color=\"tab:orange\", label=\"resampled\")\nax.plot(df_interpolated1, '.', color=\"tab:purple\", zorder=-1,\n        label=f\"time-interpolated\")\nax.plot(df_interpolated2, '.', color=\"tab:cyan\", zorder=-2,\n        label=f\"nearest-interpolated\")\nax.legend()\n\nax.set(xlabel=\"time\",\n       ylabel=\"temperature (deg C)\")\n\n[Text(0.5, 0, 'time'), Text(0, 0.5, 'temperature (deg C)')]"
  },
  {
    "objectID": "introduction/first-steps.html#smoothing-noisy-data",
    "href": "introduction/first-steps.html#smoothing-noisy-data",
    "title": "2  First Steps — basic time series analysis",
    "section": "2.3 Smoothing noisy data",
    "text": "2.3 Smoothing noisy data\nLet’s first download data from a different project.\n\nfilename2 = \"test_peleg.csv\"\n# if file is not there, go fetch it from thingspeak\nif not os.path.isfile(filename2):\n    # define what to download\n    channels = \"1708067\"\n    fields = \"1,2,3,4,5\"\n    minutes = \"30\"\n\n    # https://www.mathworks.com/help/thingspeak/readdata.html\n    # format YYYY-MM-DD%20HH:NN:SS\n    start = \"2022-05-15%2000:00:00\"\n    end = \"2022-05-25%2000:00:00\"\n\n    # download using Thingspeak's API\n    # url = f\"https://api.thingspeak.com/channels/{channels}/fields/{fields}.csv?minutes={minutes}\"\n    url = f\"https://api.thingspeak.com/channels/{channels}/fields/{fields}.csv?start={start}&end={end}\"\n    data = urllib.request.urlopen(url)\n    d = data.read()\n\n    # save data to csv\n    file = open(filename2, \"w\")\n    file.write(d.decode('UTF-8'))\n    file.close()\n\n\n# load data\ndf = pd.read_csv(filename2)\n# rename columns\ndf = df.rename(columns={\"created_at\": \"timestamp\",\n                        \"field1\": \"T\",\n                        \"field2\": \"Tw\",\n                        \"field3\": \"RH\",\n                        \"field4\": \"VPD\",\n                        \"field5\": \"dist\",\n                        })\n# set timestamp as index\ndf['timestamp'] = pd.to_datetime(df['timestamp'])\ndf = df.set_index('timestamp')\n\n\ndf\n\n\n\n\n\n\n\n\nentry_id\nT\nTw\nRH\nVPD\ndist\n\n\ntimestamp\n\n\n\n\n\n\n\n\n\n\n2022-05-18 20:09:31+00:00\n24716\n23.85\n23.3125\n65.32\n1.02532\n7.208\n\n\n2022-05-18 20:10:32+00:00\n24717\n23.88\n23.2500\n65.32\n1.02717\n7.208\n\n\n2022-05-18 20:11:33+00:00\n24718\n23.90\n23.2500\n65.23\n1.03107\n7.276\n\n\n2022-05-18 20:12:33+00:00\n24719\n23.90\n23.2500\n65.19\n1.03226\n7.208\n\n\n2022-05-18 20:13:34+00:00\n24720\n23.89\n23.2500\n65.15\n1.03282\n7.633\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n2022-05-24 12:18:35+00:00\n32711\n27.47\n26.1250\n47.49\n1.92397\n8.925\n\n\n2022-05-24 12:19:36+00:00\n32712\n27.47\n26.1250\n47.62\n1.91921\n8.925\n\n\n2022-05-24 12:20:39+00:00\n32713\n27.47\n26.1250\n47.96\n1.90675\n8.925\n\n\n2022-05-24 12:21:40+00:00\n32714\n27.47\n26.1875\n47.75\n1.91444\n8.925\n\n\n2022-05-24 12:22:41+00:00\n32715\n27.49\n26.1875\n47.94\n1.90971\n8.925\n\n\n\n\n8000 rows × 6 columns"
  },
  {
    "objectID": "introduction/first-steps.html#smoothing-noisy-data-1",
    "href": "introduction/first-steps.html#smoothing-noisy-data-1",
    "title": "2  First Steps — basic time series analysis",
    "section": "2.4 Smoothing noisy data",
    "text": "2.4 Smoothing noisy data\n\n# %matplotlib widget\n\nfig, ax = plt.subplots(1, figsize=(8,4))\n\nax.plot(df['RH'], '.')\n# add labels and title\nax.set(xlabel = \"time\",\n       ylabel = \"RH (%)\",\n       title = \"Relative Humidity\")\n# makes slanted dates\nplt.gcf().autofmt_xdate()  \n\n\n\n\n\n2.4.1 Moving average and SavGol\n\n# %matplotlib widget\n\nfig, ax = plt.subplots(1, figsize=(8,4))\n\n# apply a rolling average of size \"window_size\",\n# it can be either by number of points, or by window time\n# window_size = 30  # number of measurements\nwindow_size = '120min'  # minutes\nRH_smooth = df['RH'].rolling(window_size, center=True).mean().to_frame()\nRH_smooth.rename(columns={'RH': 'rolling_avg'}, inplace=True)\n\nRH_smooth['SG'] = savgol_filter(df['RH'], window_length=121, polyorder=2)\n\nax.plot(df['RH'], color=\"tab:blue\", label=\"data\")\nax.plot(RH_smooth['rolling_avg'], color=\"tab:orange\", label=\"moving average\")\nax.plot(RH_smooth['SG'], color=\"tab:red\", label=\"Savitzky-Golay filter\")\n# add labels and title\nax.set(xlabel = \"time\",\n       ylabel = \"RH (%)\",\n       title = \"Relative Humidity\")\n# makes slanted dates\nplt.gcf().autofmt_xdate()\nax.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fe6a0525730&gt;"
  },
  {
    "objectID": "smoothing/convolution.html#convolution",
    "href": "smoothing/convolution.html#convolution",
    "title": "3  Convolution",
    "section": "3.1 Convolution",
    "text": "3.1 Convolution\nConvolution is a fancy word for averaging a time series using a running window. We will use the terms convolution, running average, and rolling average interchangeably. See the animation below. We take all temperature values inside a window of width 500 minutes (51 points), and average them with equal weights. The weights profile is called kernel.\n\n\nThe pink curve is much smoother than the original! However, the running average cannot describe sharp temperature changes. If we decrease the window width to 200 minutes (21 points), we get the following result.\n\n\nThere is a tradeoff between the smoothness of a curve, and its ability to describe sharp temporal changes."
  },
  {
    "objectID": "smoothing/convolution.html#kernels",
    "href": "smoothing/convolution.html#kernels",
    "title": "3  Convolution",
    "section": "3.2 Kernels",
    "text": "3.2 Kernels\nWe can modify our running average, so that values closer to the center of the window have higher weights, and those further away count less. This is achieved by changing the weight profile, or the shape of the kernel. We see below the result of a running average using a triangular window of base 500 minutes (51 points).\n\n\nThings can get as fancy as we want. Instead of a triangular kernel, which has sharp edges, we can choose a smoother gaussian kernel, see the difference below. We used a gaussian kernel with 60-minute standard deviation (the window in the animation is 4 standard deviations wide)."
  },
  {
    "objectID": "smoothing/convolution.html#math",
    "href": "smoothing/convolution.html#math",
    "title": "3  Convolution",
    "section": "3.3 Math",
    "text": "3.3 Math\nThe definition of a convolution between signal \\(f(t)\\) and kernel \\(k(t)\\) is\n\\[\n(f * k)(t) = \\int f(\\tau)k(t-\\tau)d\\tau.\n\\]\nThe expression \\(f*k\\) denotes the convolution of these two functions. The argument of \\(k\\) is \\(t-\\tau\\), meaning that the kernel runs from left to right (as \\(t\\) does), and at every point the two signals (\\(f\\) and \\(k\\)) are multiplied together. It is the product of the signal with the weight function \\(k\\) that gives us an average. Because of \\(-\\tau\\), the kernel is flipped backwards, but this has no effect to symmetric kernels, like to ones in the examples above. Finally, the actual running average is not the convolution, but\n\\[\n\\frac{(f * k)(t)}{\\displaystyle \\int k(t)dt}.\n\\]\nWhenever the integral of the kernel is 1, then the convolution will be identical with the running average."
  },
  {
    "objectID": "smoothing/convolution.html#numerics",
    "href": "smoothing/convolution.html#numerics",
    "title": "3  Convolution",
    "section": "3.4 Numerics",
    "text": "3.4 Numerics\nRunning averages are very common tools in time-series analysis. The pandas package makes life quite simple. For example, in order to calculate the running average of temperature using a rectangular kernel, one writes\ndf['temperature'].rolling(window='20', center=True).mean()\n\nwindow=20 means that the width of the window is 20 points. Pandas lets us define a window width in time units, for example, window='120min'.\ncenter=True is needed in order to assign the result of averaging to the center of the window. Make it False and see what happens.\nmean() is the actual calculation, the average of temperature over the window. The rolling part does not compute anything, it just creates a moving window, and we are free to calculate whatever we want. Try to calculate the standard deviation or the maximum, for example.\n\nIt is implicit in the command above a “rectangular” kernel. What if we want other shapes?\n\n3.4.1 Gaussian\n(\ndf['temperature'].rolling(window=window_width,\n                          center=True,\n                          win_type=\"gaussian\")\n                 .mean(std=std_gaussian)\n)\nwhere * window_width is an integer, number of points in your window * std_gaussian is the standard deviation of your gaussian, measured in sample points, not time!\nFor instance, if we have measurements every 10 minutes, and our window width is 500 minutes, then window_width = 500/10 + 1 (first and last included). If we want a standard deviation of 60 minutes, then std_gaussian = 6. The gaussian kernel will look like this:\n\nYou can take a look at various options for kernel shapes here, provided by the scipy package. The graph above was achieved by running:\ng = scipy.signal.gaussian(window_width, std)\nplt.plot(g)\n\n\n3.4.2 Triangular\nSame idea as gaussian, but simpler, because we don’t need to think about standard deviation.\n(\ndf['temperature'].rolling(window=window_width,\n                          center=True,\n                          win_type=\"triang\")\n                 .mean()\n)"
  },
  {
    "objectID": "smoothing/convolution.html#which-window-shape-and-width-to-choose",
    "href": "smoothing/convolution.html#which-window-shape-and-width-to-choose",
    "title": "3  Convolution",
    "section": "3.5 🤷‍♂️ Which window shape and width to choose?",
    "text": "3.5 🤷‍♂️ Which window shape and width to choose?\nSorry, there is not definite answer here… It really depends on your data and what you need to do with it. See below a comparison of all examples in the videos above."
  },
  {
    "objectID": "lags/cross-correlation.html",
    "href": "lags/cross-correlation.html",
    "title": "4  Cross-correlation",
    "section": "",
    "text": "import numpy as np\n\n\nprint('dfvdfv')\n\ndfvdfv"
  },
  {
    "objectID": "lags/LDTW.html",
    "href": "lags/LDTW.html",
    "title": "6  LDTW",
    "section": "",
    "text": "according to this paper"
  },
  {
    "objectID": "seasonality/seasonal-decomposition.html",
    "href": "seasonality/seasonal-decomposition.html",
    "title": "7  Seasonal Decomposition",
    "section": "",
    "text": "8 Trends in Atmospheric Carbon Dioxide\nMauna Loa CO2 concentration.\ndata from NOAA\nurl = \"https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_weekly_mlo.csv\"\ndf = pd.read_csv(url, header=47, na_values=[-999.99])\n\n# you can first download, and then read the csv\n# filename = \"co2_weekly_mlo.csv\"\n# df = pd.read_csv(filename, header=47, na_values=[-999.99])\n\ndf\n\n\n\n\n\n\n\n\nyear\nmonth\nday\ndecimal\naverage\nndays\n1 year ago\n10 years ago\nincrease since 1800\n\n\n\n\n0\n1974\n5\n19\n1974.3795\n333.37\n5\nNaN\nNaN\n50.40\n\n\n1\n1974\n5\n26\n1974.3986\n332.95\n6\nNaN\nNaN\n50.06\n\n\n2\n1974\n6\n2\n1974.4178\n332.35\n5\nNaN\nNaN\n49.60\n\n\n3\n1974\n6\n9\n1974.4370\n332.20\n7\nNaN\nNaN\n49.65\n\n\n4\n1974\n6\n16\n1974.4562\n332.37\n7\nNaN\nNaN\n50.06\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2510\n2022\n6\n26\n2022.4836\n420.31\n7\n418.14\n395.36\n138.71\n\n\n2511\n2022\n7\n3\n2022.5027\n419.73\n6\n417.49\n395.15\n138.64\n\n\n2512\n2022\n7\n10\n2022.5219\n419.08\n6\n417.25\n394.59\n138.52\n\n\n2513\n2022\n7\n17\n2022.5411\n418.43\n6\n417.14\n394.64\n138.41\n\n\n2514\n2022\n7\n24\n2022.5603\n417.84\n6\n415.68\n394.11\n138.36\n\n\n\n\n2515 rows × 9 columns\ndf['date'] = pd.to_datetime(df[['year', 'month', 'day']])\ndf = df.set_index('date')\ndf\n\n\n\n\n\n\n\n\nyear\nmonth\nday\ndecimal\naverage\nndays\n1 year ago\n10 years ago\nincrease since 1800\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n\n1974-05-19\n1974\n5\n19\n1974.3795\n333.37\n5\nNaN\nNaN\n50.40\n\n\n1974-05-26\n1974\n5\n26\n1974.3986\n332.95\n6\nNaN\nNaN\n50.06\n\n\n1974-06-02\n1974\n6\n2\n1974.4178\n332.35\n5\nNaN\nNaN\n49.60\n\n\n1974-06-09\n1974\n6\n9\n1974.4370\n332.20\n7\nNaN\nNaN\n49.65\n\n\n1974-06-16\n1974\n6\n16\n1974.4562\n332.37\n7\nNaN\nNaN\n50.06\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2022-06-26\n2022\n6\n26\n2022.4836\n420.31\n7\n418.14\n395.36\n138.71\n\n\n2022-07-03\n2022\n7\n3\n2022.5027\n419.73\n6\n417.49\n395.15\n138.64\n\n\n2022-07-10\n2022\n7\n10\n2022.5219\n419.08\n6\n417.25\n394.59\n138.52\n\n\n2022-07-17\n2022\n7\n17\n2022.5411\n418.43\n6\n417.14\n394.64\n138.41\n\n\n2022-07-24\n2022\n7\n24\n2022.5603\n417.84\n6\n415.68\n394.11\n138.36\n\n\n\n\n2515 rows × 9 columns\n# %matplotlib widget\n\nfig, ax = plt.subplots(1, figsize=(8,6))\nax.plot(df['average'])\nax.set(xlabel=\"date\",\n       ylabel=\"CO2 concentration (ppm)\",\n       # ylim=[0, 430],\n       title=\"Mauna Loa CO2 concentration\");\nfill missing data. interpolate method: ‘time’\ninterpolation methods visualized\ndf['co2'] = (df['average'].resample(\"D\") #resample daily\n                          .interpolate(method='time') #interpolate by time\n            )\ndf\n\n\n\n\n\n\n\n\nyear\nmonth\nday\ndecimal\naverage\nndays\n1 year ago\n10 years ago\nincrease since 1800\nco2\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1974-05-19\n1974\n5\n19\n1974.3795\n333.37\n5\nNaN\nNaN\n50.40\n333.37\n\n\n1974-05-26\n1974\n5\n26\n1974.3986\n332.95\n6\nNaN\nNaN\n50.06\n332.95\n\n\n1974-06-02\n1974\n6\n2\n1974.4178\n332.35\n5\nNaN\nNaN\n49.60\n332.35\n\n\n1974-06-09\n1974\n6\n9\n1974.4370\n332.20\n7\nNaN\nNaN\n49.65\n332.20\n\n\n1974-06-16\n1974\n6\n16\n1974.4562\n332.37\n7\nNaN\nNaN\n50.06\n332.37\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2022-06-26\n2022\n6\n26\n2022.4836\n420.31\n7\n418.14\n395.36\n138.71\n420.31\n\n\n2022-07-03\n2022\n7\n3\n2022.5027\n419.73\n6\n417.49\n395.15\n138.64\n419.73\n\n\n2022-07-10\n2022\n7\n10\n2022.5219\n419.08\n6\n417.25\n394.59\n138.52\n419.08\n\n\n2022-07-17\n2022\n7\n17\n2022.5411\n418.43\n6\n417.14\n394.64\n138.41\n418.43\n\n\n2022-07-24\n2022\n7\n24\n2022.5603\n417.84\n6\n415.68\n394.11\n138.36\n417.84\n\n\n\n\n2515 rows × 10 columns"
  },
  {
    "objectID": "seasonality/seasonal-decomposition.html#decompose-data",
    "href": "seasonality/seasonal-decomposition.html#decompose-data",
    "title": "7  Seasonal Decomposition",
    "section": "8.1 decompose data",
    "text": "8.1 decompose data\nseasonal_decompose returns an object with four components:\n\nobserved: \\(Y(t)\\)\ntrend: \\(T(t)\\)\nseasonal: \\(S(t)\\)\nresid: \\(e(t)\\)\n\nAdditive model: \\[\nY(t) = T(t) + S(t) + e(t)\n\\]\nMultiplicative model: \\[\nY(t) = T(t) \\times S(t) \\times e(t)\n\\]\n\n8.1.0.1 Interlude\nlearn how to use zip in a loop\n\nletters = ['a', 'b', 'c', 'd', 'e']\nnumbers = [1, 2, 3, 4, 5]\n# zip let's us iterate over to lists at the same time\nfor l, n in zip(letters, numbers):\n    print(f\"{l} = {n}\")\n\na = 1\nb = 2\nc = 3\nd = 4\ne = 5\n\n\nPlot each component separately.\n\n# %matplotlib widget\n\nfig, ax = plt.subplots(4, 1, figsize=(8,6), sharex=True)\ndecomposed_m = seasonal_decompose(df['co2'], model='multiplicative')\ndecomposed_a = seasonal_decompose(df['co2'], model='additive')\ndecomposed = decomposed_m\npos = (0.5, 0.9)\ncomponents =[\"observed\", \"trend\", \"seasonal\", \"resid\"]\ncolors = [\"tab:blue\", \"tab:orange\", \"tab:green\", \"tab:red\"]\nfor axx, component, color in zip(ax, components, colors):\n    data = getattr(decomposed, component)\n    axx.plot(data, color=color)\n    axx.text(*pos, component, bbox=dict(facecolor='white', alpha=0.8),\n           transform=axx.transAxes, ha='center', va='top')\n\n\n\n\n\n# %matplotlib widget\n\ndecomposed = decomposed_m\n\nfig, ax = plt.subplots(1, 2, figsize=(10,6))\nax[0].plot(df['co2'], color=\"tab:blue\", label=\"observed\")\nax[0].plot(decomposed.trend * decomposed.resid, color=\"tab:orange\", label=\"trend*resid\")\nax[0].plot(decomposed.trend * decomposed.seasonal, color=\"tab:red\", label=\"trend*seasonal\")\nax[0].plot(decomposed.trend, color=\"black\", label=\"trend\")\nax[0].set(ylabel=\"CO$_2$ concentration (ppm)\",\n          title=\"Mauna Loa CO$_2$ concentration\")\nax[0].legend(frameon=False)\n\nstart = \"2000-01-01\"\nend = \"2003-01-01\"\nzoom = slice(start, end)\nax[1].plot(df.loc[zoom, 'co2'], color=\"tab:blue\", label=\"observed\")\nax[1].plot((decomposed.trend * decomposed.resid)[zoom], color=\"tab:orange\", label=\"trend*resid\")\nax[1].plot((decomposed.trend * decomposed.seasonal)[zoom], color=\"tab:red\", label=\"trend*seasonal\")\nax[1].plot(decomposed.trend[zoom], color=\"black\", label=\"trend\")\ndate_form = DateFormatter(\"%Y\")\nax[1].xaxis.set_major_formatter(date_form)\nax[1].xaxis.set_major_locator(mdates.YearLocator(1))\nax[1].set_title(\"Components, 2000--2003\");"
  },
  {
    "objectID": "technical-stuff/technical-stuff.html#operating-systems",
    "href": "technical-stuff/technical-stuff.html#operating-systems",
    "title": "Technical Stuff",
    "section": "Operating systems",
    "text": "Operating systems\nI recommend working with UNIX-based operating systems (MacOS or Linux). Everything is easier.\nIf you use Windows, consider installing Linux on Windows with WSL."
  },
  {
    "objectID": "technical-stuff/technical-stuff.html#software",
    "href": "technical-stuff/technical-stuff.html#software",
    "title": "Technical Stuff",
    "section": "Software",
    "text": "Software\nAnaconda’s Python distribution\nVSCode"
  },
  {
    "objectID": "technical-stuff/technical-stuff.html#python-packages",
    "href": "technical-stuff/technical-stuff.html#python-packages",
    "title": "Technical Stuff",
    "section": "Python packages",
    "text": "Python packages\nKats — a one-stop shop for time series analysis\nDeveloped by Meta\nstatsmodels statsmodels is a Python package that provides a complement to scipy for statistical computations including descriptive statistics and estimation and inference for statistical models.\nydata-profiling\nQuick Exploratory Data Analysis on time-series data. Read also this."
  },
  {
    "objectID": "references.html#books",
    "href": "references.html#books",
    "title": "Sources",
    "section": "Books",
    "text": "Books\nfrom Data to Viz\nFundamentals of Data Visualization, by Claus O. Wilke\nPyNotes in Agriscience\nForecasting: Principles and Practice (3rd ed), by Rob J Hyndman and George Athanasopoulos\nPython for Finance Cookbook 2nd Edition - Code Repository\nPractical time series analysis,: prediction with statistics and machine learning, by Aileen Nielsen\nThe online edition of this book is available for Hebrew University staff and students.\nTime series analysis with Python cookbook : practical recipes for exploratory data analysis, data preparation, forecasting, and model evaluation, by Tarek A. Atwan\nThe online edition of this book is available for Hebrew University staff and students.\nHands-on Time Series Analysis with Python: From Basics to Bleeding Edge Techniques, by B V Vishwas, Ashish Patel\nThe online edition of this book is available for Hebrew University staff and students."
  },
  {
    "objectID": "references.html#videos",
    "href": "references.html#videos",
    "title": "Sources",
    "section": "Videos",
    "text": "Videos\nTimes Series Analysis for Everyone, by Bruno Goncalves\nThis series is available for Hebrew University staff and students.\nTime Series Analysis with Pandas, by Joshua Malina This video is available for Hebrew University staff and students."
  },
  {
    "objectID": "references.html#references",
    "href": "references.html#references",
    "title": "Sources",
    "section": "References",
    "text": "References\n\n\nAtwan, Tarek A. 2022. Time Series Analysis with Python Cookbook:\nPractical Recipes for Exploratory Data Analysis, Data Preparation,\nForecasting, and Model Evaluation. Packt."
  }
]